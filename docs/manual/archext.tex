%====================================================
% ARCHITECTURAL EXTENSIONS
%====================================================
\section{Architecture Extensions}
\label{sec:archext}
%
uMPU does not modify the ISA of the embedded processor.
%
Memory protection is provided by changing the implementation of certain instructions.
%
%Modification of instructions:The store instruction is modified so that the appropriate checks are performed before it is executed. The call and return instructions are modified so that when these calls cause a domain change, that information is recorded to perform correct checks during the store instruction. %
\begin{table}[htdp]
\centering
\small{
\begin{tabular}{|l|c|c|}
	\hline
	Instruction & Normal & Modified\\
	\hline
	Store & 2 & 3\\
	Call & 4 & 9\\
	Return & 4 & 9\\
	\hline
\end{tabular}}
\caption{Overhead (CPU cycles) of architecture extensions}
\label{tab:perfimpact}
\end{table}
%Table~\ref{tab:perfimpact} shows the additional cost incurred in performing a store with protection enabled and performing a cross-domain call and return. The additional clock cycles are necessary because the modified instructions require additional access to the data memory. The store instruction reads one byte of information to perform ownership checks. The call and return instruction store and read five bytes of information respectively. The information consists of one byte of domain ID of the previous domain, two bytes of stack bound to protect previous domain’s stack and two bytes of return address required to check for a cross-domain return. Store Instruction:Before a store instruction is executed and the memory location at the store address is modified, it is necessary to ensure that the currently active domain has ownership of that block of memory. To read the ownership information from the memmap region, an offset pertaining to the store address is calculated. The offset is calculated based on the block size and record size. The block size is the granularity at which memory is allocated to domains and record size indicates how many bits are contained in each record. Starting with the store address, log base two of block size bits are used as the block offset. Of the remaining bits, one or two bits are used to select the correct record in the byte. The remaining bits in the address are used as an offset into memmap. In the first clock cycle, this offset is calculated using completely combinational logic. In the second clock cycle a read is performed on the specified address and ownership information is verified. Finally in the third clock cycle, the actual write to the store address is performed. The extra clock cycle is only required when memory protection is enabled. Call and Return Instructions:One domain is allowed to call into other domains by using jump tables setup in the FLASH memory. The callee exports its entry points to the jump tables, which the caller can access. Each time such an event occurs; the currently active domain information has to be updated to perform correct ownership checks in the new domain. During a cross-domain call, it is necessary to push information pertaining to the previous domain into the safe stack and during a cross-domain return; the information is popped from the safe stack. Along with the return address, the addition information stored consists of the domain ID and the stack bound. The domain ID is used to update the domain information on a cross-domain return. The stack bound is used to perform additional checks on store instructions so a domain is not allowed to modify other domains’ stack area. The safe stack is hidden from the programmer. This ensures that the corruption of the stack area of one domain will still keep the stack information pertaining to the previous domain safe. On a cross-domain call, during the first two clock cycles, the two bytes return address is pushed on the safe stack, then the two bytes stack bound is pushed and then finally one byte for the domain ID is pushed. On a cross-domain return, the information is popped from the stack in the similar manner. If a normal call or return occurs, the extra information is not required and only four clock cycles are needed.We will now discuss the different architectural modules designed and implemented in the architecture.Memory Map Checker module (MMC):This module has two primary tasks: track the current domain and perform the ownership checks on store instructions. The domain tracker and safe stack can detect a change in domain and inform this module of the change. This module keeps track of the change and uses the most updated information when performing the ownership checks. When the processor starts to execute a store instruction, it informs the MMC of the execution. If the protection is enabled, i.e. the current domain is not the trusted domain, MMC responds by stalling the processor in the next clock cycle. During the stall, the MMC copies the store address and store data generated by the processor and performs its own read for the ownership information. After receiving the results of the read, it performs the ownership check. If the check passes, in the next clock cycle, the MMC performs the write on the processor’s behalf. Stores to stack are allowed with one simple check that the stack bound is maintained. Therefore stores to the stack also only require two clock cycles.Domain Tracker module:This module detects a cross-domain call and then computes the new domain ID. When a cross-domain call is detected, this module informs the MMC to update its current domain information and informs the safe stack to push additional information in its stack. When the processor starts to execute a call instruction, it informs this module. The domain tracker checks if the call was to the jump table. It the call is not to the jump table, it is assumed that this is not a cross-domain call. If the call is to the jump table, this module computes the new domain ID. In the jump table, each domain is given a fixed amount of space to export functions. Based on the offset from the beginning of the jump table, this module can compute the new domain ID. It signals the MMC and the safe stack of the new domain and also provides them with the new domain ID. Safe Stack:This module pushes and pops the return address on the safe stack during a normal call and return instruction respectively. During a cross-domain call and return it pushes and pops the return address, stack bound and domain ID respectively. The processor informs this module when it is executing a call or a return instruction. The domain tracker informs this module when it detects a cross-domain call. Based on the information pushed to the safe stack during a cross-domain call, this module detects a cross-domain return. It informs MMC of the domain change on a cross-domain return. When a cross-domain call or return is detected, this module stalls the processor for three additional clock cycles. It uses those cycles to push or pop the two bytes of stack bound and one byte of domain ID. This module always maintains the current stack bound, used by the MMC to check writes to the stack.Bus Arbiter module:Before the processor was modified with the above extensions, the processor had the sole possession of the data memory. It was the only module that was allowed to read or write to the memory. However, in the present design MMC and stack also read and write to the memory. This requires a multiplexing mechanism for the memory bus between these three entities. The processor typically uses the bus, but the MMC or the safe stack can use it by generating the appropriate multiplexing signals. The MMC uses the bus when it reads the ownership information and when it performs the write on behalf of the processor. The safe stack replaces the stack address with the safe stack address on call and return instructions. On cross-domain instructions it reads and writes the stack bound and domain ID to the safe stack.Software visible registers:The hardware has a high degree of configurability. Setting the following programmer visible registers can configure it. Only the trusted domain is allowed access to these registers. It is the responsibility of the trusted domain to properly configure the hardware and setup the supporting software for correct execution of the memory protection mechanism. Mem\_map\_pointer:This register should point to the beginning of the memmap area in the memory. The MMC module uses this register when reading the ownership information from the memory. It is also required that the memmap region of the memory be properly initialized before untrusted domains are executed. Mem\_prot\_bottom:The protection mechanism allows for protection of any contiguous region of memory. This allows in flexibility when it is necessary to protect memory mapped IO, peripherals and memory regions for the trusted domain. This register sets the lower bound of the protected memory. Mem\_prot\_top:Similar to above, this register sets the upper bound of the protected memory. Mmc\_status\_reg:This register is used to specify the block size used by the software to allocate memory and the number of records stored per byte in the memmap. This register also exposes the currently running domain to software. The most significant three bits are used to specify the log of the block size. The next three bits specify the currently running domain. These bits cannot be written to in software and are used to specify the currently running domain. The next bit specifies the number of records per byte in memmap. If the bit is set, there are four records per byte. This also implies that there are only operational domains. If the bit is not set, there are two records per byte and eight operational domains. Safe\_stack\_pointer:This register is used to specify the safe stack pointer similar to the normal stack pointer. Even if the processor is to be used with protection disabled, presently it is important to set this register correctly. This is required because the return addresses are always stored in the safe stack regardless of the protection. This is a small limitation of the system and can be eliminated. The safe stack grows up towards the normal and both the stacks approach one another. As the safe stack stores stack bounds and grows towards the normal stack, it can used to implement stack overflow detection. Jump\_table:This register should point to the beginning of the jump table in FLASH memory. Domain tracker does not read from it but uses the address stored in here to compute the offset into the jump table in memory. This offset is used to compute the domain ID of the new domain. Modifications to the Processor:The actual processor had to be modified to communicate with the rest of the modules. It is modified to inform MMC when it is executing a store instruction, domain tracker on a call instruction and safe stack on a call and return instruction. It is also modified to accept the stall signals from MMC and safe stack and stall itself in the correct state when the signals are set.